diff --git a/pilot/pkg/bootstrap/server.go b/pilot/pkg/bootstrap/server.go
--- a/pilot/pkg/bootstrap/server.go	(revision 9a2d8e67bfe4ccd522649a5018965bb4f7a6c516)
+++ b/pilot/pkg/bootstrap/server.go	(date 1627997677037)
@@ -21,6 +21,8 @@
 	"encoding/json"
 	"errors"
 	"fmt"
+	"github.com/spiffe/go-spiffe/v2/spiffeid"
+	"github.com/spiffe/go-spiffe/v2/workloadapi"
 	"io/ioutil"
 	"net"
 	"net/http"
@@ -175,6 +177,9 @@
 	statusReporter *status.Reporter
 	// RWConfigStore is the configstore which allows updates, particularly for status.
 	RWConfigStore model.ConfigStoreCache
+
+	// source of X.509 certs and bundle, when using SPIRE as cert provider
+	x509Source *workloadapi.X509Source
 }

 // NewServer creates a new Server instance based on the provided arguments.
@@ -205,6 +210,16 @@
 	for _, fn := range initFuncs {
 		fn(s)
 	}
+
+	if strings.EqualFold(features.PilotCertProvider.Get(), SpireCertProvider) {
+		ctx := context.Background()
+		x509Source, err := workloadapi.NewX509Source(ctx)
+		if err != nil {
+			return nil, fmt.Errorf("failed creating spiffe X.509 source: %v", err)
+		}
+		s.x509Source = x509Source
+	}
+
 	// Initialize workload Trust Bundle before XDS Server
 	e.TrustBundle = s.workloadTrustBundle
 	s.XDSServer = xds.NewDiscoveryServer(e, args.Plugins, args.PodName, args.Namespace)
@@ -927,6 +942,29 @@

 // initIstiodCerts creates Istiod certificates and also sets up watches to them.
 func (s *Server) initIstiodCerts(args *PilotArgs, host string) error {
+
+	pilotCertProvider := features.PilotCertProvider.Get()
+	log.Infof("pilotCertProvider: %s", pilotCertProvider)
+
+	if strings.EqualFold(pilotCertProvider, SpireCertProvider) {
+
+		chain, key, err := s.getCertAndKeyBytes()
+		if err != nil {
+			return err
+		}
+
+		bundleBytes, err := s.getBundleBytes()
+		if err != nil {
+			return err
+		}
+
+		s.setIstioCertBundleAndNotify(chain, key, bundleBytes)
+
+		s.watchIstioCertUpdates()
+
+		return nil
+	}
+
 	if err := s.maybeInitDNSCerts(args, host); err != nil {
 		return fmt.Errorf("error initializing DNS certs: %v", err)
 	}
@@ -939,6 +977,60 @@
 	return nil
 }

+func (s *Server) watchIstioCertUpdates() {
+	go func() {
+		updatedChan := s.x509Source.Updated()
+		for {
+			<-updatedChan
+			chain, key, err := s.getCertAndKeyBytes()
+			if err != nil {
+				log.Errorf("error watching SPIRE updates: %v", err)
+				continue
+			}
+
+			bundleBytes, err := s.getBundleBytes()
+			if err != nil {
+				log.Errorf("error watching SPIRE updates: %v", err)
+				continue
+			}
+
+			s.setIstioCertBundleAndNotify(chain, key, bundleBytes)
+		}
+	}()
+}
+
+func (s *Server) getCertAndKeyBytes() ([]byte, []byte, error) {
+	svid, err := s.x509Source.GetX509SVID()
+	if err != nil {
+		return nil, nil, fmt.Errorf("failed fetching X.509 SVID: %v", err)
+	}
+
+	chain, key, err := svid.Marshal()
+	if err != nil {
+		return nil, nil, fmt.Errorf("unable to marshal X.509 SVID: %v", err)
+	}
+
+	return chain, key, nil
+}
+
+func (s *Server) getBundleBytes() ([]byte, error) {
+	trustDomain, err := spiffeid.TrustDomainFromString(spiffe.GetTrustDomain())
+	if err != nil {
+		return nil, fmt.Errorf("error trying to parse trust domain %q reason: %v", spiffe.GetTrustDomain(), err)
+	}
+
+	bundle, err := s.x509Source.GetX509BundleForTrustDomain(trustDomain)
+	if err != nil {
+		return nil, fmt.Errorf("unable to find X.509 bundle for trust domain %q: %v", trustDomain, err)
+	}
+
+	bundleBytes, err := bundle.Marshal()
+	if err != nil {
+		return nil, fmt.Errorf("unable to marshal X.509 byndle: %v", err)
+	}
+	return bundleBytes, nil
+}
+
 // shouldInitDNSCerts returns whether DNS certs need to be signed.
 func (s *Server) shouldInitDNSCerts(args *PilotArgs) bool {
 	if hasCustomTLSCerts(args.ServerOptions.TLSOptions) {
@@ -968,7 +1060,7 @@

 // createPeerCertVerifier creates a SPIFFE certificate verifier with the current istiod configuration.
 func (s *Server) createPeerCertVerifier(tlsOptions TLSOptions) (*spiffe.PeerCertVerifier, error) {
-	if tlsOptions.CaCertFile == "" && s.CA == nil && features.SpiffeBundleEndpoints == "" {
+	if tlsOptions.CaCertFile == "" && s.CA == nil && features.SpiffeBundleEndpoints == "" && strings.ToLower(features.PilotCertProvider.Get()) != SpireCertProvider {
 		// Running locally without configured certs - no TLS mode
 		return nil, nil
 	}
@@ -1004,6 +1096,18 @@
 		peerCertVerifier.AddMappings(certMap)
 	}

+	if strings.EqualFold(features.PilotCertProvider.Get(), SpireCertProvider) {
+		bundleBytes, err := s.getBundleBytes()
+		if err != nil {
+			return nil, err
+		}
+
+		err = peerCertVerifier.AddMappingFromPEM(spiffe.GetTrustDomain(), bundleBytes)
+		if err != nil {
+			return nil, fmt.Errorf("add root CAs into peerCertVerifier failed: %v", err)
+		}
+	}
+
 	return peerCertVerifier, nil
 }

diff --git a/pilot/pkg/bootstrap/certcontroller.go b/pilot/pkg/bootstrap/certcontroller.go
--- a/pilot/pkg/bootstrap/certcontroller.go	(revision 9a2d8e67bfe4ccd522649a5018965bb4f7a6c516)
+++ b/pilot/pkg/bootstrap/certcontroller.go	(date 1627563043199)
@@ -48,6 +48,7 @@
 var (
 	KubernetesCAProvider = "kubernetes"
 	IstiodCAProvider     = "istiod"
+	SpireCertProvider    = "spire"
 )
 
 // CertController can create certificates signed by K8S server.
@@ -199,6 +200,35 @@
 	}
 }
 
+func (s *Server) setIstioCertBundleAndNotify(certChain []byte, key []byte, bundle []byte) {
+	keyPair, err := tls.X509KeyPair(certChain, key)
+
+	if err != nil {
+		log.Errorf("istiod loading x509 key pairs failed: %v", err)
+		return
+	}
+	for _, c := range keyPair.Certificate {
+		x509Cert, err := x509.ParseCertificates(c)
+		if err != nil {
+			log.Errorf("x509 cert - ParseCertificates() error: %v", err)
+			return
+		}
+		for _, c := range x509Cert {
+			log.Infof("x509 cert - Issuer: %q, Subject: %q, SN: %x, NotBefore: %q, NotAfter: %q",
+				c.Issuer, c.Subject, c.SerialNumber,
+				c.NotBefore.Format(time.RFC3339), c.NotAfter.Format(time.RFC3339))
+		}
+	}
+
+	s.certMu.Lock()
+	s.istiodCert = &keyPair
+	s.certMu.Unlock()
+	log.Info("istiod certificates are set")
+
+	s.istiodCertBundleWatcher.SetAndNotify(nil, nil, bundle)
+	log.Info("istiod Cert Bundle Watcher notified")
+}
+
 // initCertificateWatches sets up watches for the dns certs.
 // 1. plugin cert
 // 2. istiod signed certs.
