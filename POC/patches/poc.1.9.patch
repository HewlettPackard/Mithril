diff --git a/pilot/pkg/bootstrap/server.go b/pilot/pkg/bootstrap/server.go
index 0d1130cf54..eff42061f1 100644
--- a/pilot/pkg/bootstrap/server.go
+++ b/pilot/pkg/bootstrap/server.go
@@ -901,6 +901,7 @@ func onlyStatusUpdated(old config.Config, curr config.Config) bool {
 		labels.Equals(old.Annotations, curr.Annotations) && reflect.DeepEqual(old.Spec, curr.Spec)
 }
 
+//TODO: this is the place to look into for istiod
 // initIstiodCerts creates Istiod certificates and also sets up watches to them.
 func (s *Server) initIstiodCerts(args *PilotArgs, host string) error {
 	if err := s.maybeInitDNSCerts(args, host); err != nil {
@@ -919,6 +920,7 @@ func (s *Server) initIstiodCerts(args *PilotArgs, host string) error {
 func (s *Server) maybeInitDNSCerts(args *PilotArgs, host string) error {
 	// Generate DNS certificates only if custom certs are not provided via args.
 	if !hasCustomTLSCerts(args.ServerOptions.TLSOptions) && s.EnableCA() {
+		//TODO: read below
 		// Create DNS certificates. This allows injector, validation to work without Citadel, and
 		// allows secure SDS connections to Istiod.
 		log.Infof("initializing Istiod DNS certificates host: %s, custom host: %s", host, features.IstiodServiceCustomHost.Get())
diff --git a/pilot/pkg/networking/core/v1alpha3/cluster.go b/pilot/pkg/networking/core/v1alpha3/cluster.go
index 4ad461375d..fe4031cac7 100644
--- a/pilot/pkg/networking/core/v1alpha3/cluster.go
+++ b/pilot/pkg/networking/core/v1alpha3/cluster.go
@@ -17,6 +17,7 @@ package v1alpha3
 import (
 	"fmt"
 	"math"
+	"net/url"
 	"strconv"
 	"strings"
 
@@ -943,9 +944,19 @@ func buildUpstreamClusterTLSContext(opts *buildClusterOpts, tls *networking.Clie
 		tlsContext.CommonTlsContext.TlsCertificateSdsSecretConfigs = append(tlsContext.CommonTlsContext.TlsCertificateSdsSecretConfigs,
 			authn_model.ConstructSdsSecretConfig(model.GetOrDefault(metadataSDS.GetResourceName(), authn_model.SDSDefaultResourceName), proxy))
 
+		var sans []string
+		for _, san := range tls.SubjectAltNames {
+			u, err := url.Parse(san)
+			if err != nil {
+				continue
+			}
+			sans = append(sans, u.Scheme+"://"+u.Host)
+		}
+
 		tlsContext.CommonTlsContext.ValidationContextType = &auth.CommonTlsContext_CombinedValidationContext{
 			CombinedValidationContext: &auth.CommonTlsContext_CombinedCertificateValidationContext{
-				DefaultValidationContext: &auth.CertificateValidationContext{MatchSubjectAltNames: util.StringToExactMatch(tls.SubjectAltNames)},
+				// DefaultValidationContext: &auth.CertificateValidationContext{MatchSubjectAltNames: util.StringToExactMatch(tls.SubjectAltNames)},
+				DefaultValidationContext: &auth.CertificateValidationContext{MatchSubjectAltNames: util.StringToPrefixMatch(sans)},
 				ValidationContextSdsSecretConfig: authn_model.ConstructSdsSecretConfig(model.GetOrDefault(metadataSDS.GetRootResourceName(),
 					authn_model.SDSRootResourceName), proxy),
 			},
diff --git a/pkg/istio-agent/agent.go b/pkg/istio-agent/agent.go
index e822481531..32927edb77 100644
--- a/pkg/istio-agent/agent.go
+++ b/pkg/istio-agent/agent.go
@@ -56,6 +56,7 @@ const (
 	// Location of K8S CA root.
 	k8sCAPath = "./var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
 
+	//TODO we might need to change this. Or the config map?
 	// CitadelCACertPath is the directory for Citadel CA certificate.
 	// This is mounted from config map 'istio-ca-root-cert'. Part of startup,
 	// this may be replaced with ./etc/certs, if a root-cert.pem is found, to
@@ -239,6 +240,7 @@ func (sa *Agent) FindRootCAForXDS() string {
 	} else {
 		// PILOT_CERT_PROVIDER - default is istiod
 		// This is the default - a mounted config map on K8S
+		// TODO: look into this
 		return path.Join(CitadelCACertPath, constants.CACertNamespaceConfigMapDataName)
 	}
 }
@@ -266,6 +268,7 @@ func (sa *Agent) FindRootCAForCA() string {
 	}
 }
 
+// TODO: look into this
 // newSecretManager creates the SecretManager for workload secrets
 func (sa *Agent) newSecretManager() (*cache.SecretManagerClient, error) {
 	// If proxy is using file mounted certs, we do not have to connect to CA.
@@ -298,6 +301,7 @@ func (sa *Agent) newSecretManager() (*cache.SecretManagerClient, error) {
 		log.Warn("Debug mode or IP-secure network")
 	}
 	if tls {
+		//TODO: might be relevant
 		caCertFile := sa.FindRootCAForCA()
 		if caCertFile == "" {
 			log.Infof("Using CA %s cert with system certs", sa.secOpts.CAEndpoint)
diff --git a/pkg/spiffe/spiffe.go b/pkg/spiffe/spiffe.go
index 2e6e3b1054..fe22d23923 100644
--- a/pkg/spiffe/spiffe.go
+++ b/pkg/spiffe/spiffe.go
@@ -65,17 +65,24 @@ func ParseIdentity(s string) (Identity, error) {
 	if !strings.HasPrefix(s, URIPrefix) {
 		return Identity{}, fmt.Errorf("identity is not a spiffe format: %v", s)
 	}
+	// split := strings.Split(s[URIPrefixLen:], "/")
+	// if len(split) != 5 {
+	// 	return Identity{}, fmt.Errorf("identity is not a spiffe format due to length: %v", s)
+	// }
+	// if split[1] != NamespaceSegment || split[3] != ServiceAccountSegment {
+	// 	return Identity{}, fmt.Errorf("identity is not a spiffe format: %v", s)
+	// }
+	// return Identity{
+	// 	TrustDomain:    split[0],
+	// 	Namespace:      split[2],
+	// 	ServiceAccount: split[4],
+	// }, nil
+
 	split := strings.Split(s[URIPrefixLen:], "/")
-	if len(split) != 5 {
-		return Identity{}, fmt.Errorf("identity is not a spiffe format: %v", s)
-	}
-	if split[1] != NamespaceSegment || split[3] != ServiceAccountSegment {
-		return Identity{}, fmt.Errorf("identity is not a spiffe format: %v", s)
-	}
 	return Identity{
 		TrustDomain:    split[0],
-		Namespace:      split[2],
-		ServiceAccount: split[4],
+		Namespace:      "fakens",
+		ServiceAccount: "fakesa",
 	}, nil
 }
 
